BUFFER SIZE IS IN BYTES.

// This stuff is going to have to go.
//ao_initialize();
//ao_sample_format out_format;
//int out_driver_id = ao_default_driver_id();
//	out_format.bits = 16;
//	out_format.channels = 2;
//	out_format.rate = 44100;
//	out_format.byte_format = AO_FMT_LITTLE;
//ao_device* out_device = ao_open_live(out_driver_id, &out_format,NULL);

// This is the actual play thing.
ao_play(out_device, wavout, BUFFER_SIZE);

// Do this to clean up.
ao_shutdown();



// Lame API notes:

How to:
lame_global_flags *lamehandle = lame_init(); // where lamehandle is the general handle for handling this encode stream
lame_set_brate(lamehandle, 256); // set up bitrate , etc, etc, etc
lame_init_params(lamehandle); // having done all that, init it.

/*
Input is fed to the lame lib using the lame_encode_buffer_XXXXX function. Sometimes, depending on how much it has
encoded, it will spit out some usable mp3 junk. If the input is too small to make at least one frame it won't output
anything. the output buffer will seldom always be filled. Make sure output buffer is big enough to handle, else bad
stuff happens. (Make same size as input easiest).
*/
{
	encoding_status = lame_encode_buffer_interleaved(
		lamehandle,
		input_buffer,
		input_buffer_size,
		ouput_buffer,
		output_buffer_size);

	if (encoding_status>0)
		fwrite(encout, 1, encoding_status,outputfile);
}

cli app passes args
options:
ops object calls decoders
coders refer to obs objects/structs

mainloop object passes coder options

use cases:
	cli, ie, all args are passed through
	lib in specfic case, all/most args are already known
	lib in generic case (gui), all args are generated interpreted, options
	need to be queried from coders
	
	cli use case
	code says;
		I have file to decode;
		loads modules
		modules give list of supported file formats (somehow)
		checks against list of supported file formats
		loads decoder, asks decoder, what are your supported options
		decoder returns struct/object with list/callbacks [or use setoption?]
		loop calls getargs object parser
		loop passes decoder.setargs(cliargs.getdecoderoptions())
		
		
	lib (gui) use case
		loads modules
		modules give list of supported file formats (somehow)
		user selects output format (encoder)
		loop asks module for options
		encoder returns struct of options
		encoder option screen extends options object as mogvguiopt, which loads with an 
		user clicks ok
		user clicks run
		decoder is setup
		loops passes encoder.setargs(mogvguiopt.getencoderoptions();
		
decoder, encoder, need to implement

		getOptions
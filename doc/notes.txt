BUFFER SIZE IS IN BYTES.

// This stuff is going to have to go.
//ao_initialize();
//ao_sample_format out_format;
//int out_driver_id = ao_default_driver_id();
//	out_format.bits = 16;
//	out_format.channels = 2;
//	out_format.rate = 44100;
//	out_format.byte_format = AO_FMT_LITTLE;
//ao_device* out_device = ao_open_live(out_driver_id, &out_format,NULL);

// This is the actual play thing.
ao_play(out_device, wavout, BUFFER_SIZE);

// Do this to clean up.
ao_shutdown();



// Lame API notes:

How to:
lame_global_flags *lamehandle = lame_init(); // where lamehandle is the general handle for handling this encode stream
lame_set_brate(lamehandle, 256); // set up bitrate , etc, etc, etc
lame_init_params(lamehandle); // having done all that, init it.

/*
Input is fed to the lame lib using the lame_encode_buffer_XXXXX function. Sometimes, depending on how much it has
encoded, it will spit out some usable mp3 junk. If the input is too small to make at least one frame it won't output
anything. the output buffer will seldom always be filled. Make sure output buffer is big enough to handle, else bad
stuff happens. (Make same size as input easiest).
*/
{
	encoding_status = lame_encode_buffer_interleaved(
		lamehandle,
		input_buffer,
		input_buffer_size,
		ouput_buffer,
		output_buffer_size);

	if (encoding_status>0)
		fwrite(encout, 1, encoding_status,outputfile);
}

// NOTE: reconsider encoder/decoder inheritance , may have modules that
// implement both - avoid overlapping functions

cli app passes args
options:
ops object calls decoders
coders refer to obs objects/structs

mainloop object passes coder options

use cases:
	cli, ie, all args are passed through
	lib in specfic case, all/most args are already known
	lib in generic case (gui), all args are generated interpreted, options
	need to be queried from coders
	
	cli use case
	code says;
		I have file to decode;
		loads modules
		modules give list of supported file formats (somehow) # NOTE: causes issue where opts are parsed twice
		checks against list of supported file formats
		loads decoder, asks decoder, what are your supported options
		decoder returns struct/object with list/callbacks [or use setoption?]
		loop calls getargs object parser
		loop passes decoder.setargs(cliargs.getdecoderoptions())
		
		
		issues: Need to parse for coder type first, which may require parsing file exts

		then load modules apropriately, and parse those options
			if all are reg'd, not particularly efficent (though need to do this for file types / magic numbers anyway)
			> non-autodetec on ext or magic numbers should be special / unusal case anyway
			Also, if multiple input types, there should be handling of passing multiple options
			so; --decode-mp3-skip-id3v1 | --decode-flac-map-chans=1,2,0,0,0 ( map left right, and drop LR, RR, and center channels) should work
			> register options & filetypes (?) with mogvOption
			mogvCliOptions mogvcliopt->registerDecoder(); -- can't pass classes by reference
			> steps; register filetypes
concept; decoder option name, which is sometimes (but not always the same as the file type)
		prepend decoder option to decoder type, internal structure of class, filetypes, opts
		how to register class implementations, need self registering proxy objects
		>	singleton class (self creating at runtime) list of modules
		> proxy classes for each module that contain the listing of each module
		
		Modules listing class - self registers;
			mogvModuleRegister - singleton
			mogvProxy - virtual, include code to register, default to none, with warning
	
	CLI use case on above;
		module proxy load automatically, and register selves with singleton mogvModuleRegister
		loop calls (mogopt) mogvCliOptions(argc,v)
		
		mogvModuleRegister->getEncoderByExt ->getDecoderByMagic ->getDecoderByName
		
		loop calls mogopt->getIteration (rename)
				getIteration() returns struct with
					input
					ouput
					decoder
					encoder
				getEmptyIteration() returns struct with
					input
					output
					decoder
					encoder
					decoder_options
					encoder_options
					...
				Private;
					decoder_options (hash map with type)
					input_file (singular)
					output_file (singular)
					program_options ??
				Internal flow;
				Constructer:
					read argc/v
					where --decoder-{type}-{opt} = value
						check if valid with mogvModuleRegister()  (or internal)
						decoder_options[$type][$opt] = value;
						repeat for other module types
					where --opt
						program_options[$opt] = value //  hashmap?
					where input
						input list // start with one item
					
				
				getIteration()
					pop item from list
					
		
		
		loads modules
		modules give list of supported file formats (somehow) # NOTE: causes issue where opts are parsed twice
		checks against list of supported file formats
		loads decoder, asks decoder, what are your supported options
		decoder returns struct/object with list/callbacks [or use setoption?]
		loop calls getargs object parser
		loop passes decoder.setargs(cliargs.getdecoderoptions())
		

		
		
	lib (gui) use case
		loads modules
		modules give list of supported file formats (somehow)
		user selects output format (encoder)
		loop asks module for options
		encoder returns struct of options
		encoder option screen extends options object as mogvguiopt, which loads with an 
		user clicks ok
		user clicks run
		decoder is setup
		loops passes encoder.setargs(mogvguiopt.getencoderoptions();


		
decoder, encoder, need to implement

		getOptions // List of options
			* Options are name,type,function/callback
			* Have virtual methods in super class for registering, and processing
			  options and options vector list
			